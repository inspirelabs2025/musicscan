import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('üöÄ Discogs blog generator triggered');

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Get new Discogs releases from the last 24 hours that don't have blogs yet
    const { data: newReleases, error: fetchError } = await supabase
      .from('discogs_releases_shown')
      .select(`
        discogs_id,
        artist,
        title,
        created_at
      `)
      .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString())
      .order('created_at', { ascending: false });

    if (fetchError) {
      throw fetchError;
    }

    if (!newReleases || newReleases.length === 0) {
      console.log('üîç No new releases found');
      return new Response(JSON.stringify({
        success: true,
        message: 'No new releases to process',
        processed: 0
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    console.log(`üì¶ Found ${newReleases.length} new releases`);

    let processed = 0;
    let errors = 0;

    for (const release of newReleases.slice(0, 5)) { // Process max 5 at a time
      try {
        console.log(`üìù Processing: ${release.artist} - ${release.title}`);

        // Check if blog already exists
        const { data: existingBlog } = await supabase
          .from('blog_posts')
          .select('id')
          .eq('yaml_frontmatter->discogs_id', release.discogs_id)
          .maybeSingle();

        if (existingBlog) {
          console.log(`‚è≠Ô∏è Blog already exists for ${release.title}`);
          continue;
        }

        // Create release in releases table first
        const { data: releaseResult, error: releaseError } = await supabase.functions.invoke('find-or-create-release', {
          body: {
            discogs_id: release.discogs_id,
            artist: release.artist,
            title: release.title,
            discogs_url: `https://www.discogs.com/release/${release.discogs_id}`
          }
        });

        if (releaseError) {
          console.warn(`‚ö†Ô∏è Failed to create release for ${release.title}:`, releaseError);
          continue;
        }

        const releaseId = releaseResult?.release_id;
        if (!releaseId) {
          console.warn(`‚ö†Ô∏è No release_id returned for ${release.title}`);
          continue;
        }

        // Generate blog
        const { data: blogResult, error: blogError } = await supabase.functions.invoke('plaat-verhaal-generator', {
          body: {
            albumId: releaseId,
            albumType: 'vinyl', // Default to vinyl for Discogs
            forceRegenerate: false,
            autoGenerated: true,
            autoPublish: true
          }
        });

        if (blogError) {
          console.warn(`‚ö†Ô∏è Blog generation failed for ${release.title}:`, blogError);
          errors++;
        } else {
          console.log(`‚úÖ Blog generated for: ${release.title}`);
          processed++;
        }

        // Small delay to avoid rate limits
        await new Promise(resolve => setTimeout(resolve, 2000));

      } catch (error) {
        console.error(`‚ùå Error processing ${release.title}:`, error);
        errors++;
      }
    }

    console.log(`‚úÖ Discogs blog generation complete: ${processed} processed, ${errors} errors`);

    return new Response(JSON.stringify({
      success: true,
      message: `Processed ${processed} releases`,
      processed,
      errors,
      total_found: newReleases.length
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('‚ùå Error in discogs-blog-generator:', error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});